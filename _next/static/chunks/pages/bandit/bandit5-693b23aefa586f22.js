(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[862],{80419:function(e,i,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/bandit/bandit5",function(){return n(7605)}])},90654:function(e,i,n){"use strict";var t=n(85893),s=n(23457),l=n.n(s),a=n(5227),o=n(84283);i.Z=function(e){var i=e.children,n=e.language;return(0,t.jsx)("div",{className:l().CodeBlock,children:(0,t.jsx)(a.Z,{language:n,style:o.cL,children:i})})}},69242:function(e,i,n){"use strict";var t=n(85893),s=n(41664),l=n(98574),a=n.n(l);i.Z=function(e){var i=e.link1,n=e.link2;return(0,t.jsxs)("div",{className:a().pageNav,children:[(0,t.jsx)("div",{children:i?(0,t.jsx)(s.default,{href:i,children:(0,t.jsx)("a",{title:"Previous page",className:a().navButton,children:"\u25c0"})}):""}),(0,t.jsx)("div",{children:n?(0,t.jsx)(s.default,{href:n,children:(0,t.jsx)("a",{title:"Next page",className:a().navButton,children:"\u25b6"})}):""})]})}},20586:function(e,i,n){"use strict";var t=n(85893),s=n(86655),l=n.n(s),a=n(5227),o=n(84283),r=n(67294);i.Z=function(e){var i=e.children,n=(0,r.useState)(!1),s=n[0],c=n[1];return(0,t.jsxs)("section",{children:[(0,t.jsx)("h2",{children:"Key"}),(0,t.jsxs)("div",{className:l().codeBlock,children:[(0,t.jsx)("div",{className:l().spoilerToggler,children:(0,t.jsx)("button",{onClick:function(){return c(!s)},children:"Click to Reveal"})}),(0,t.jsx)("div",{className:l().spoilerContainer,children:(0,t.jsx)("div",{className:"".concat(l().spoiler," ").concat(s?l().show:""),children:(0,t.jsx)(a.Z,{language:"",style:o.cL,customStyle:{margin:0},children:i})})})]})]})}},7605:function(e,i,n){"use strict";n.r(i);var t=n(85893),s=n(90654),l=n(69242),a=n(20586);i.default=function(){return(0,t.jsxs)("div",{children:[(0,t.jsx)("h1",{children:"Bandit 5"}),(0,t.jsxs)("section",{children:[(0,t.jsx)("h2",{children:"Experience"}),(0,t.jsxs)("p",{children:["Seems familiar to Bandit 4, this time, we are instructed to find a file that is human-readable, 1033 bytes in size and not an executable. I could try something similar to how I solved Bandit 4, however, it doesn't specifically give files which meet the criteria. I didn't know where to go for this level. However, looking at the overthewire website, we are told about commands that may be useful, the one that seem most relevant was ",(0,t.jsx)("code",{children:"find"}),"."]}),(0,t.jsxs)("p",{children:["Using just ",(0,t.jsx)("code",{children:"find"}),", it returns all the files on the directories. Reading further about the function, there are several flags that can be useful. To select a 1033 byte file, we could use ",(0,t.jsx)("code",{children:"-size 1033c"}),". To select non-executable, we could use",(0,t.jsx)("code",{children:"! -executable"}),". The last criteria of being human readable was a bit less clear. One possible way I found was to use the ",(0,t.jsx)("code",{children:"-exec"})," flag which allows find to run other commands."]}),(0,t.jsx)(s.Z,{language:"shell",children:"find ! -executable -size 1033c -exec file {} ';'"}),(0,t.jsx)("p",{}),(0,t.jsxs)("p",{children:["Learnt about using the find command and found a ",(0,t.jsx)("a",{href:"https://unix.stackexchange.com/questions/389705/understanding-the-exec-option-of-find",children:"useful explanation"})," about the ",(0,t.jsx)("code",{children:"-exec"})," flag. Using it like in the code above will find all files that are not executable and have a size of 1033 bytes then list what type of file they are. This could further be modified by adding ",(0,t.jsx)("code",{children:"grep"})," to get all the files which are of a specific type, like so:"]}),(0,t.jsx)(s.Z,{language:"shell",children:"find ! -executable -size 1033c -exec file {} ';' | grep ASCII"})]}),(0,t.jsxs)("section",{children:[(0,t.jsx)("h2",{children:"Reflection"}),(0,t.jsx)("p",{children:"This was actually a really nice learning experience, though it was not overly challenging, it really highlighted the point of doing all these to explore what tools exist."}),(0,t.jsxs)("p",{children:["In terms of security again, this could be a potential method of exploring target's files, what directories exist. More interestingly, we could see that this is a potential method of exploiting file searching. Say that a web server searchest through a directory using the ",(0,t.jsx)("code",{children:"find"})," command. Then, we could perform other shell commands using the ",(0,t.jsx)("code",{children:"-exec"})," flag. This also showcased how blacklisting might not be a viable solution. For example, a person could prevent users from inputting other commands by blacklisting semicolons. Well, the ",(0,t.jsx)("code",{children:"-exec"})," flag would actually not need semicolons. The one above does use it, but you could also use a plus instead. So there are many many ways of doing the same things and as a defender, you might not always think about all those potential ways."]})]}),(0,t.jsx)(a.Z,{children:"DXjZPULLxYr17uwoI01bNLQbtFemEgo7"}),(0,t.jsx)(l.Z,{link1:"/bandit/bandit4",link2:"/natas"})]})}},23457:function(e){e.exports={CodeBlock:"CodeBlock_CodeBlock___IBBd"}},98574:function(e){e.exports={pageNav:"PageNav_pageNav__NXqbT",navButton:"PageNav_navButton__yHhmO"}},86655:function(e){e.exports={codeBlock:"SpoilerKey_codeBlock__KWl0d",spoilerToggler:"SpoilerKey_spoilerToggler__HCeWZ",spoiler:"SpoilerKey_spoiler__YWx_s",show:"SpoilerKey_show__VIJ75",spoilerContainer:"SpoilerKey_spoilerContainer__O76It"}}},function(e){e.O(0,[369,774,888,179],(function(){return i=80419,e(e.s=i);var i}));var i=e.O();_N_E=i}]);